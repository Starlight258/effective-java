## ✍️ 개념의 배경

### 불변 클래스

> 인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다.
> 

* **객체가 파괴되는 순간**까지 불변 인스턴스의 정보는 **고정되어있다**. 예시) String, BigInteger, BigDecimal, 래핑 클래스

---

* 객체가 파괴되는 순간: 객체의 생명주기(lifecycle)에서 해당 객체가 메모리에서 소멸되거나 제거되는 시점을 가리키는 즉, GC가 작동하였다는 뜻.

### 불변 클래스를 만들기 위한 규칙 다섯가지

> 클래스 확장이 불가하다.
> 

> 모든 필드를 private으로 선언한다.
> 

> 모든 필드를 final로 선언한다.
> 

> 객체의 상태를 변경하는 메서드를 제공하지 않는다.
> 

> 다른 객체는 내부의 가변 컴포넌트에 접근할 수 없다.
> 

### 방어적 복사

**생성자의 인자로 가변 객체를 받아 내부 필드를 초기화** 하거나, **getter 메서드에서 내부 객체를 반환할 때, 객체의 복사본을 만들어 반환**하는 것이다. 아래는 후자의 예다.

이를 진행하는 제일 중요한 이유는 가변 객체가 다른 코드에 전달되거나 반환할 때 원치 않는 변경이 발생할 수 있기 때문이다. 

```java
public static BigInteger safeInstance(BigInteger val) {
	return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray());
}
```

# 요약

---

### 불변 객체의 장점

<aside>
🔑 불변 클래스는 설계/구현/사용이 쉽다. 또한 오류가 생길 여지가 적으며 안전하다.

</aside>

> **1. 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다.**
> 

임의의 복잡한 상태에 놓이지 않아서 믿고 사용할 수 있다.

```java
public final class Complex {
	private final double re;
	private final double im;

	public Complex(double re, double im){
		this.re = re;
		this.im = im;
	}

	public Complex plus(Complex c){
		return new Complex(re + c.re, im + c.im);	
	}
}
```

실수부와 허수부로 구성된 복소수 클래스에서, plus 메서드는 인스턴스 자신을 수정하는 것이 아니라, 새로운 Complex 인스턴스를 만들어 반환한다. 즉 피연산자에 함수를 적용해 그 결과를 반환하지만 피연산자 자체는 그대로인 **함수형 프로그래밍 방식**이다. 

> **2.  thread-safe하여 동기화할 필요가 없다.**
> 

따라서 불변 객체는 안심하고 공유할 수 있다. 재활용이 수월하다는 뜻이다. 

> **3. 불변 객체를 자유로이 공유하고, 내부 데이터를 공유할 수 있다.**
> 

불변 객체를 자유롭게 공유할 수 있으므로 굳이 방어적 복사도 필요하지 않다. 따라서 불변 클래스는 clone 메서드나 복사 생성자를 제공하지 않는 것이 좋다. 

`BigInteger`의 예시처럼, **값의 부호와 크기를 따로** 표현한다. 

> **4. 다른 불변 객체를 구성요소로 사용하면 좋다.**
> 

**`Map`** 키와 **`Set`**의 원소로 사용하기 좋다. 만약 캐시나 **`Map`**, **`Set`** 등의 원소인 가변 객체가 변경되었다면 이를 갱신하는 등의 부가 작업이 필요할 것이다. 하지만 불변 객체라면 **한 번 데이터가 저장된 이후에 다른 작업들을 고려하지 않아도 되므로** 사용하는데 용이하게 작용할 것이다.

> **5. 상태가 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다.**
> 

원자성을 잘 유지한다.

---

### 불변 객체의 단점

> **1. 값이 다르면 반드시 독립된 객체로 만들어야한다.**
> 

**값의 가짓수가 많다면 이들을 모두 만드는 데 큰 비용**을 치루어야한다. 

ex) 백만비트짜리 `BigInteger`에서 비트 하나를 바꾼다고 할 때도 새로운 인스턴스를 생성해야하는 반면 `BitSet`은 가변이라서 해당 비트만 바꿔주는 메서드를 제공한다. 

> **2. 객체 생성 단계가 많고, 그 중간 단계에서 만들어진 객체들이 모두 버려지면 성능 문제가 더욱 커진다.**
> 

**이를 보완하기위해,**

- **다단계 연산**으로 각 단계마다 객체를 생성하지 않는다. ex) `BigInteger`의 모듈러 지수(나머지를 구하는 연산)

### 불변 클래스 설계법

> 상속이 불가하게 만들어야한다.
> 

그 방법 중 하나로는 정적 팩터리를 제공하는 것이다. 모든 생성자를 private || package-private으로 만든다. 

- 유연하고, 객체 캐싱 기능을 추가해 성능을 끌어올릴 수 있다.

`BigInteger`, `BigDecimal`의 메서드들은 잘못 설계되어 재정의할 수 있어서, 하위 호환성이 문제가 된다. 따라서 신뢰할 수 없는 클라이언트로부터 해당 인스턴스를 인수로 받으면 진짜 `BigInteger`, `BigDecimal`인지 확인해야한다. 그것이 아니라면 방어적 복사를 하여야한다.

> 성능이 우려되면 메서드가 객체의 외부에서 보이는 값을 변경할 수 없는 정도로 규칙을 완화해도 된다.
> 

계산 비용이 큰 값을 나중에 계산하여 final이 아닌 필드에 캐시해두기도 한다. ex) **`hashCode`** 메서드

## 결론

- 클래스는 꼭 필요한 경우가 아니면 불변이어야한다.
- 그러나 모든 클래스를 불변으로 만들 수는 없으므로, 변경할 부분이 있다면 그를 최소화한다. private final이 기본값.
- 생성자는 불변식 설정이 모두 완료되어 초기화가 완벽히 끝난 상태의 객체를 생성해야한다. ex **`CountDownLatch`**
