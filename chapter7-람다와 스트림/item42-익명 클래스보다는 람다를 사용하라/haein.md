## 요약

### 람다 방식으로 작성한 코드는 익명 클래스보다 그 의미가 명확해진다

```java
Collections.sort(words, new Comparator<String>() {
	public int compare(String s1, String s2){
		return Integer.compare(s1.length(), s2.length());
	}
})
```

```java
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```
- 자바8 부터 함수형 인터페이스와 람다식을 이용해 코드가 어떤 동작을 하는 지 명확하게 드러낼 수 있다


### 람다가 익명 클래스를 대체할 수 없는 경우
- 추상 클래스의 인스턴스를 만드는 경우 
- 추상 메서드가 여러 개인 인터페이스를 구현하는 경우
- 인스턴스가 자기 자신을 참조해야 하는 경우(람다의 this 는 바깥 인스턴스를 의미한다)

### 람다와 직렬화

람다는 익명 클래스처럼 직렬화 형태가 구현별로 다르다. 직렬화해야하는 함수 객체는 private 중첩 클래스의 인스턴스를 사용하자


## 추가 지식

### 람다 표현식
- 파라미터, 화살표, 람다 바디로 구성된다
- 바디는 expression 으로 구성하거나 {statements;} 로 구성할 수 있다 
    - (List<String> list) -> list.isEmpty()
    - () -> new Apple()
    - (a) -> {System.out.println(a.getWeight());}
    - (int a, int b) -> a * b 

### 형식 검사, 추론, 제약
- 람다는 콘텍스트를 통해 형식을 추론한다
- 대상 형식 : 콘텍스트에서 기대되는 람다 표현식의 형식(람다가 전달될 메서드 파라미터나 람다가 할당되는 변수 등)
- 같은 람다식이 다른 함수형 인터페이스에 할당될 수 있다 
- 람다 바디에 일반 표현식이 있으면 void 를 반환하는 함수 디스크럽터와 호환된다 
- 컴파일러는 람다 표현식의 파라미터 형식에 접근할 수 있으므로 이를 생략할 수 있다

### 지역 변수 
- 람다가 외부 변수(자유 변수) 를 사용할 때 지역 변수인 경우 명시적으로 final 인 경우이거나 실질적으로 fianl 인 변수와 똑같이 사용되어야 한다
- 인스턴스 변수는 힙에 저장되지만, 지역 변수는 스택에 위치하므로 변수 할당이 해제되었는데 람다가 변수에 접근하는 경우를 위해 람다는 변수의 복사본을 사용한다 따라서 지역 변수에 값을 한 번만 할당해야 한다는 제약이 존재한다 









