# 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라
## 작업 큐
- `java.util.concurrent` : **실행자 프레임워크**라고 하는 인터페이스 기반의 유연한 태스크 실행 기능이다.
    - **실행자 서비스** : 태스크를 수행하는 일반적인 메커니즘
        - 원하는 태스크 수행 정책을 선택할 수 있고, 생각이 바뀌면 언제든 변경할 수 있다.
            - **작업 로직**을 한 번만 작성하면 되고, **실행 컨텍스트를 쉽게 변경**할 수 있다. (단일 스레드, 스레드 풀, 새 스레드 등)
        - 실행자 프레임워크가 작업 수행을 담당해준다.
        - `작업 제출 (Runnable)`과 `실행 메커니즘(실행자 서비스)`을 분리한다.
    - **태스크** : 실행자 프레임워크에서 **작업 단위**를 나타내는 핵심 추상 개념
        - `Runnable` : 실행 가능한 작업
        - `Callable` : `Runnable`과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있다.
```java
ExecutorService exec = Executors.newSingleThreadExecutor();
// 실행자에 작업 넘기기
exec.execute(runnable);
// 실행자를 우아하게 종료시키기
exec.shutdown();
```

### 큐를 둘 이상의 스레드가 처리하도록 하기
- **다른 정적 팩터리**를 이용하여 다른 종류의 실행자 서비스(스레드 풀)을 생성하면 된다.
- 스레드 풀의 스레드 개수는 고정할 수도 있고 필요에 따라 늘어나거나 줄어들게 설정할 수도 있다.

### Executors의 정적 팩터리
- 대부분의 실행자는 `Executors의 정적 팩터리`들을 이용해 생성할 수 있다.
    - 평범하지 않은 실행자를 원한다면 `ThreadPoolExecutor` 클래스를 직접 사용해도 된다.
- **작은 프로그램이나 가벼운 서버** : `Executors.newCachedThreadPool`
    - 요청받은 태스크들이 큐에 쌓이지 않고 **즉시 스레드에 위임돼 실행**된다.
    - 가용한 스레드가 없다면 새로 하나를 생성한다.
    - 서버가 아주 무겁다면 CPU 이용률이 100%로 치닫고, 새로운 태스크가 도착하는 족족 또 다른 스레드를 생성하며 상황을 더욱 악화시킨다.
- **무거운 프로덕션 서버**
    - 스레드 개수를 고정한 `Executors.newFixedThreadPool`
    - 완전히 통제가능한 `ThreadPoolExecutor` (가장 세밀한 제어)
- 작업 큐를 직접 구현하거나 스레드를 직접 관리하는 것은 권장되지 않는다.
    - 스레드를 직접 다루면 Thread가 작업 단위와 수행 메커니즘 역할을 모두 수행해야 한다.
    - 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다.

### 포크-조인(fork-join) 태스크
- **포크-조인 풀**이라는 특별한 실행자 서비스가 실행해준다.
    - 포크-조인 태스크를 실행하기 위한 특별한 종류의 실행자 서비스
- 작은 하위 태스크로 나뉠 수 있고, ForkJoinPool을 구성하는 스레드들이 이 태스크들을 처리한다.
    - 큰 작업을 작은 단위로 **재귀적으로 분할**하여 **병렬로 처리하는 방식**이다.
- 일을 먼저 끝낸 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리한다.
- 모든 스레드가 바쁘게 움직여 CPU를 최대한 활용하면서 높은 처리량과 낮은 지연시간을 달성한다.
