## 요약

### Serializable 을 구현하면 릴리스한 뒤에는 수정하기 어렵다

- Serializable 을 구현하는 클래스는 그것의 직렬화 형태(바이트 스트림 인코딩) 도 하나의 API 가 되어 이를 지원해야 함
- 캡슐화가 꺠진다 : 커스텀 직렬화가 아닌 기본 직렬화는 private 로 설정된 인스턴스 필드도 API 로 공개하는 위험을 가짐
    - 커스텀 직렬화는 직렬화하는 구현체 내부에 : `readObject` `writeObject` 를 재정의하는 방식으로 구현할 수 있음
    - 역직렬화 과정을 하나의 또 다른 생성자라고 생각하면 인스턴스가 생성될 때 정해둔 검증 로직을 완전히 무시할 수 있음
    (직렬화를 피하고 싶은 필드는 `transient` 키워드를 이용)
    - 직렬화된 클래스 구현을 나중에 변경하면 역직렬화가 안됨 따라서 직렬화 가능 클래스는  직렬화 형태도 주의해서 함께 잘 설계해야 한다
- `serialVersionUID` 와 클래스 직렬화 버전 관리
    - `serialVersionUID` 는 스트림 고유 식별자로 직렬 버전을 관리할 때 사용하는 고유 식별 번호이다
    - 직렬화 클래스에서 private static long 필드로 만들어지며 사용자가 명시하지 않으면 런타임에 암호해시 함수(SHA-1) 을 적용하여 자동 생성
    - 자동 생성에서는 클래스 이름, 구현한 인터페이스, 컴파일러가 자동으로 생성한 것을 포함한 대부분의 클래스 맴버들을 고려한다 따라서 내부
    구현이 바뀌면 고유 식별 번호가 바뀌게 되어 `InvalidClassException` 을 만난다
    - 따라서 `serialVersionUID` 는 수동으로 관리하는 것이 좋다 
    (식별 번호가 같다면, 나중에 추가한 필드는 `null` 로 생성된다 하지만 기본 필드의 타입을 바꾸는 것은 안된다)
    

### Serializable 구현은 버그와 보안 구멍이 생길 위험을 증가시킨다

- 역직렬화 메커니즘에 의한 “숨은 생성자” 는 생성자에서 구축한 불변식 보장, 생성 도중 공격자가 객체 내부를 
들여다볼 수 없게 해야 한다는 사실을 잊어버리기 쉽다
- 예를 들어, 특정 인스턴스 필드에 대한 검증 로직을 구현한 생성자가 있어도 직렬화는 이를 무시하고 객체를 생성할 수 있음

### 해당 클래스의 신버전을 릴리스할 때 테스트하기 어려워진다

- 직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화할 수 있는지, 그리고 그 반대도 가능한지를 검사해야 한다
- 처음 클래스를 설계할 때 커스텀 직렬화 형태를 잘 설계해 놓았다면 부담을 줄일 수 있다

### Serializable 의 구현 여부는 가볍게 결정할 사항이 아니다

- Seriallizable 구현에 따르는 이득과 비용을 잘 저울질 해야 함
- `BigInteger` `Instant` 같은 값 클래스나 컬렉션 클래스는 Serializable 구현했음
- 스레드 풀 처럼 ‘동작’ 하는 객체를 표현하는 클래스는 대부분 구현하지 않았음

### 상속용으로 설계된 클래스, 인터페이스는 대부분 Serializable 을 구현하면 안된다

- 그런 클래스를 확장, 인터페이스 구현할때 커다란 부담(직렬화의 문제점들) 을 지게 됨
- 상속용으로 설계되었으나  Serializable 을 구현한 경우 : `Throwable` , `Component`
- 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능한 경우
    - 하위 클래스에서 `finalize` 를 재정의하지 못하도록 해야한다 (자신이 재정의하고 `final` 선언)
    - 인스턴스 필드중 기본값으로 설정되면 위배되는 불변식이 있다면 `readObjectNoData` 메서드를 반드시 추가해야한다
    (`readObjectNoData`  직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 것을 위한 메서드이다)
        
        ```java
        private void readObjectNoData() throws ObjectStreamException;
        ```
        

- Serializable 을 구현하지 않았다면 자식 클래스가 이를 지원하고자 할 때 자식 클래스에게 부담이 됨
    - 상위 클래스에서 기본 생성자를 지원하면 역직렬화 가능
    - 그렇지 않다면 “직렬화 프록시 패턴” 을 사용할 것

### 내부 클래스는 직렬화를 구현하지 말아야 한다

- 내부 클래스는 바깥 인스턴스의 참조와 유효 범위 안의 지역변수들을 저장하기 위해 컴파일러가 자동으로 생성한 필드가 추가됨
- 익명 클래스와 지역 클래스의 이름 짓는 규칙이 언어 명세에도 없기 때문에 이 필드들이 클래스 정의에 어떻게 추가되는지도 정의되지 않았다
- 다시 말해 내부 클래스에 대한 직렬화 형태는 분명하지 않다
- 단 정적 맴버 클래스는 구현해도 된다