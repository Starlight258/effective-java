## 요약

### 자바 직렬화의 문제점

- 직렬화는 근본적으로 공격 범위가 너무 넓고 지속적으로 넓어져서 방어하기 어려움
- 역직렬화 (`ObjectInputStream` 의 `readObject` 메서드) 는 클래스패스 안의 거의 모든 타입의 객체를 생성할 수 있고
그 타입의 모든 코드를 실행할 수도 있으므로 타입 전체가 공격 범위가 될 수 있음
- 서드파티 라이브러리, 애플리케이션 자신의 클래스 모두 공격 대상이 될 수 있고 아무리 공격에 대비한다 해도 여전히 취약할 수 있음
    - 역직렬화는 애플리케이션에서 직접적으로 사용될 뿐만 아니라 자바 하부 시스템 (RMI, JMX, JMS 등) 에서도 간접적으로 사용되고 있다
    - 잠재적으로 위험한 동작을 수행하며 역직렬화 과정에서 호출되는  메서드를 묶어 공격할 수 있고 막대한 피해를 야기(가젯 체인)
- 역직렬화에 시간이 오래 걸리는 스트림을 역직렬화 하는 것만으로도 서비스 거부 공격에 노출될 수 있다

```java
static byte[] bomb() {
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = root;
    Set<Object> s2 = new HashSet<>();
    for (int i = 0; i<100; i++) {
        Set<Object> t1 = new HashSet<>();
        Set<Object> t2 = new HashSet<>();
        t1.add("foo"); // t1을 t2와 다르게 만든다.
        s1.add(t1);
        s1.add(t2);
        s2.add(t1);
        s2.add(t2);
        s1 = t1;
        s2 = t2;
    }
    return serialize(root); // 간결하게 하기 위해 이 메서드의 코드는 생략함
}
```

- `root` 에 동일한 구조를 가진 두개의 HashSet 이 재귀적으로 100번 더해지는 모양으로 201개의 인스턴스가 {}, {”foo”} 나 {} , {”foo”}, “foo” 를 원소로 가짐
- `root` 를 역직렬화하려면 HashCode 를 계산하는 메서드를 2^100 번 호출해야 넘게 호출해야 함
- 역직렬화는 영원히 계속되고, 이것이 잘못되었다는 신호도 받지 못함(역직렬화 폭탄)

### 직렬화 위험을 희피하는 가장 좋 방법은 아무것도 역직렬화하지 않는 것

- 새로운 시스템에서 자바 직렬화를 사용해야 할 이유는 없다
- 크로스 플랫폼 구조화된 데이터 표현은 다양한 플랫폼 지원, 우수한 성능, 풍부한 지원 도구, 활발한 커뮤니티와 전문가 집단 등 다양한 이점을 제공
    - 속성-값 으로 구성된 간단하고 구조화된 형태의 데이터 제공, 기본 타입과 배열 정도만 지원하지만 이 정도의 추상화로도
    분산 시스템을 구축하고 자바 직렬화의 문제를 희피할 수 있음
    - JSON
        - 서버와 브라우저간의 통신을 위해 고안
        - 텍스트 기반 표현으로 사람이 읽기 편함
    - 프로토콜 버퍼
        - 구글에서 제안한 오픈소스 언어, 플랫폼 독립적인 직렬화 메커니즘
        - 이진 표현으로 효율이 좋음 (데이터 크기가 작고 전송이 효율적)
        - 문서를 위한 스키마 제공 , 사람이 읽을 수 있는 형식으로도 제공

### 그럼에도 직렬화를 다루어야 할 경우

- 신뢰할 수 없는 데이터는 절대 역직렬화하면 안됨 (java-secure 에서 유일하게 붉은 글씨로 강조하는 사항)
- 직렬화를 해야 하고, 역직렬화가 안전한 지 모르겠다면 `ObjectInputFilter` 사용할 것 (자바 9부터 도입)
    - 스트림이 역직렬화되기 전에 필터링을 수행함, 클래스를 받아들이거나 거부할 수 있음
    - 기본 수용(블랙리스트), 기본 거부(화이트리스트) 방식으로 운용 가능 - 화이트리스트 방식을 추천함 (SWAT 이라는 도구로 자동 생성 가능)