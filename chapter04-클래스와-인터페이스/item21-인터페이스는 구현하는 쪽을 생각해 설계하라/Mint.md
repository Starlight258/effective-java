# 21. 인터페이스는 구현하는 쪽을 생각해 설계하라
### 디폴트 메서드
- **디폴트 메서드**: 인터페이스 내에 구현체를 가지는 메서드
    - java8부터 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드를 도입했다.
    - 핵심 컬렉션 인터페이스들에 람다를 사용하기 위해 다수의 디폴트 메서드가 추가되었다.

#### 디폴트 메서드는 **구현 클래스에 대해 아무것도 모른 채 합의 없이 무작정 삽입**될 뿐이다.
- **모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어렵다.**

### 디폴트 메서드는 기존 구현체에 **런타임 오류**를 일으킬 수 있다.
- java 8은 컬렉션 인터페이스에 꽤 많은 디폴트 메서드를 추가했고, 그 결과 기존에 짜여진 많은 java 코드가 영향을 받았다.
- ex) `Collection` 인터페이스에 추가된 `removeIf`는 `SynchronizedCollection`과 어우러지지 않는다.
    - `SynchronizedCollection`은 모든 메서드 호출 전에 `lock`을 획득하고 내부 컬렉션에 작업을 위임한 후 작업이 끝나면 `lock`을 해제한다.
    - `SynchronizedCollection`는 `removeIf`를 재정의하지않으면 동기화 메커니즘을 우회하여 다른 스레드 간섭이 발생한다.
- java 플랫폼 라이브러리에서는 **새롭게 추가된 인터페이스의 디폴트 메서드를 재정의(오버라이드)** 했다.
  또한 디폴트 메서드를 직접 호출하는 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행하도록 했다.
```java
public boolean removeIf(Predicate<? super E> filter) {  
    synchronized (mutex) {return c.removeIf(filter);}  
}
```
- java 플랫폼에 속하지 않은 다른 컬렉션 구현체들은 발맞춰 수정되지 않은 경우가 많아 문제를 가지고 있다.

### **기존 인터페이스에 디폴트 메서드를 추가하는 일은 지양**해야 한다.
- 추가하려는 디폴트 메서드가 기존 구현체들과 충돌하지 않을지 심사숙고해야한다.

### 새로운 인터페이스에 디폴트 메서드를 만드는 것은 지향해야 한다.
- 디폴트 메서드는 **표준적인 메서드 구현을 제공**하는데 아주 유용한 수단이다.
    - 디폴트 메서드는 인터페이스에 구현체를 제공한다.
- **인터페이스를 더 쉽게 구현해 활용**할 수 있게끔 해준다.
    - 인터페이스의 모든 메서드를 구현할 필요가 없다.
    - 디폴트 메서드 중 수정이 필요한 메서드만 오버라이드할 수 있다.
```java
public interface List<E> {
    default void sort(Comparator<? super E> c) {
        Collections.sort(this, c);
    }
}
```

### 디폴트 메서드 주의점
- 디폴트 메서드를 통해 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하려고 하면 안된다.
    - 이런 형태로 인터페이스를 변경하면 반드시 기존 클라이언트를 망가뜨리게 된다.

### 테스트
- **새로운 인터페이스라면 릴리스 전에 반드시 테스트**를 거쳐야 한다.
    - 수많은 개발자가 해당 인터페이스를 각자의 방식으로 구현할 것이니, 다른 방식으로 최소 3가지는 구현해 보아야 한다.
    - 클라이언트도 여러개 만들어봐야한다.
- **인터페이스를 릴리스한 후에도 결함을 수정하는 게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안된다.**

